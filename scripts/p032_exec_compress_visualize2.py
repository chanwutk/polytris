#!/usr/bin/env python3
"""
Script to create a bar chart showing compression rates for each dataset.

This script analyzes the compressed images generated by p030_exec_compress.py
and creates a visualization showing the compression rate (number of compressed images)
for each dataset using their optimal parameters.
"""

import argparse
import os
import glob
from typing import Dict, List

import matplotlib.pyplot as plt
import numpy as np

from polyis.utilities import CACHE_DIR, OPTIMAL_PARAMS


def parse_args():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(description='Create bar chart showing compression rates for each dataset')
    parser.add_argument('--datasets', nargs='+', default=list(OPTIMAL_PARAMS.keys()),
                       help='Datasets to analyze (default: all datasets in OPTIMAL_PARAMS)')
    parser.add_argument('--output', default='output/compression_rates_bar_chart.png',
                       help='Output path for the bar chart (default: output/compression_rates_bar_chart.png)')
    parser.add_argument('--verbose', action='store_true',
                       help='Print verbose output')
    return parser.parse_args()


def count_compressed_images_and_frames(dataset: str, classifier: str, tilesize: int, tilepadding: str, verbose: bool = False) -> tuple[int, int]:
    """
    Count the number of compressed images and total original frames for a specific dataset and parameters.
    
    Args:
        dataset: Dataset name
        classifier: Classifier name
        tilesize: Tile size
        tilepadding: Tile padding type ('padded' or 'unpadded')
        verbose: Whether to print verbose output
        
    Returns:
        tuple[int, int]: (total_compressed_images, total_original_frames)
    """
    total_compressed = 0
    total_original_frames = 0
    
    # Get the execution directory for this dataset
    execution_dir = os.path.join(CACHE_DIR, dataset, 'execution')
    
    if not os.path.exists(execution_dir):
        if verbose:
            print(f"    Execution directory not found: {execution_dir}")
        return 0, 0
    
    # Iterate through all video directories
    video_dirs = [d for d in os.listdir(execution_dir) 
                  if os.path.isdir(os.path.join(execution_dir, d))]
    
    if verbose:
        print(f"    Found {len(video_dirs)} video directories")
    
    for video_dir in video_dirs:
        video_path = os.path.join(execution_dir, video_dir)
        
        # Construct path to compressed images directory for this video
        images_dir = os.path.join(video_path, '030_compressed_frames', 
                                 f'{classifier}_{tilesize}_{tilepadding}', 'images')
        
        compressed_count = 0
        max_end_frame = 0
        
        if os.path.exists(images_dir):
            # Get all .jpg files in this video's images directory
            image_files = glob.glob(os.path.join(images_dir, '*.jpg'))
            compressed_count = len(image_files)
            total_compressed += compressed_count
            
            # Parse filenames to find the maximum end frame
            for image_file in image_files:
                filename = os.path.basename(image_file)
                # Filename format: {start:08d}_{end:08d}.jpg
                if filename.endswith('.jpg'):
                    try:
                        # Remove .jpg extension and split by underscore
                        name_part = filename[:-4]  # Remove .jpg
                        parts = name_part.split('_')
                        if len(parts) >= 2:
                            end_frame = int(parts[-1])  # Last part is the end frame
                            max_end_frame = max(max_end_frame, end_frame)
                    except (ValueError, IndexError) as e:
                        if verbose:
                            print(f"      {video_dir}: Could not parse filename {filename}: {e}")
        
        # The total original frames is the maximum end frame found + 1 (0-indexed)
        total_original_frames += max_end_frame + 1
        
        if verbose:
            print(f"      {video_dir}: {compressed_count} compressed images, {max_end_frame + 1} original frames (max end: {max_end_frame})")
    
    return total_compressed, total_original_frames


def get_compression_rates(datasets: List[str], verbose: bool = False) -> Dict[str, float]:
    """
    Get compression rates (as percentages) for all specified datasets using their optimal parameters.
    
    Args:
        datasets: List of dataset names to analyze
        verbose: Whether to print verbose output
        
    Returns:
        Dict[str, float]: Dictionary mapping dataset names to compression rates (as percentages)
    """
    compression_rates = {}
    
    for dataset in datasets:
        if dataset not in OPTIMAL_PARAMS:
            if verbose:
                print(f"Warning: No optimal parameters found for dataset '{dataset}', skipping...")
            continue
            
        params = OPTIMAL_PARAMS[dataset]
        classifier = params['classifier']
        tilesize = params['tilesize']
        tilepadding = params['tilepadding']
        
        if verbose:
            print(f"Analyzing dataset '{dataset}' with optimal parameters:")
            print(f"  Classifier: {classifier}")
            print(f"  Tile size: {tilesize}")
            print(f"  Tile padding: {tilepadding}")
        
        # Count compressed images and original frames across all videos in the dataset
        num_compressed, num_original = count_compressed_images_and_frames(dataset, classifier, tilesize, tilepadding, verbose)
        
        # Calculate compression rate as percentage
        if num_original > 0:
            compression_rate = (num_compressed / num_original) * 100
        else:
            compression_rate = 0.0
            
        compression_rates[dataset] = compression_rate
        
        if verbose:
            print(f"  Found {num_compressed} compressed images out of {num_original} original frames")
            print(f"  Compression rate: {compression_rate:.2f}%")
            print()
    
    return compression_rates


def create_bar_chart(compression_rates: Dict[str, float], output_path: str, verbose: bool = False):
    """
    Create a bar chart showing compression rates (as percentages) for each dataset.
    
    Args:
        compression_rates: Dictionary mapping dataset names to compression rates (as percentages)
        output_path: Path to save the chart
        verbose: Whether to print verbose output
    """
    if not compression_rates:
        print("No compression rates to plot!")
        return
    
    # Prepare data for plotting
    datasets = list(compression_rates.keys())
    rates = list(compression_rates.values())
    
    if verbose:
        print(f"Creating bar chart with {len(datasets)} datasets")
        for dataset, rate in compression_rates.items():
            print(f"  {dataset}: {rate:.2f}% compression rate")
    
    # Create the plot
    plt.figure(figsize=(12, 8))
    bars = plt.bar(datasets, rates, color='steelblue', alpha=0.7, edgecolor='black', linewidth=1)
    
    # Customize the plot
    plt.title('Compression Rates by Dataset\n(Percentage of Frames Compressed)', 
              fontsize=16, fontweight='bold', pad=20)
    plt.xlabel('Dataset', fontsize=12, fontweight='bold')
    plt.ylabel('Compression Rate (%)', fontsize=12, fontweight='bold')
    
    # Rotate x-axis labels for better readability
    plt.xticks(rotation=45, ha='right')
    
    # Add value labels on top of bars
    for bar, rate in zip(bars, rates):
        plt.text(bar.get_x() + bar.get_width()/2, bar.get_height() + max(rates)*0.01,
                f'{rate:.1f}%', ha='center', va='bottom', fontweight='bold')
    
    # Add grid for better readability
    plt.grid(axis='y', alpha=0.3, linestyle='--')
    
    # Set y-axis to show percentages (0-100)
    plt.ylim(0, 100)
    
    # Adjust layout to prevent label cutoff
    plt.tight_layout()
    
    # Create output directory if it doesn't exist
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    
    # Save the plot
    plt.savefig(output_path, dpi=300, bbox_inches='tight')
    plt.close()
    
    print(f"Bar chart saved to: {output_path}")


def main(args):
    """
    Main function to create compression rate bar chart.
    
    Args:
        args: Parsed command line arguments
    """
    if args.verbose:
        print("Starting compression rate analysis...")
        print(f"Cache directory: {CACHE_DIR}")
        print(f"Datasets to analyze: {args.datasets}")
        print()
    
    # Get compression rates for all datasets
    compression_rates = get_compression_rates(args.datasets, args.verbose)
    
    if not compression_rates:
        print("No compression data found for any dataset!")
        return
    
    # Create and save the bar chart
    create_bar_chart(compression_rates, args.output, args.verbose)
    
    # Print summary
    print(f"\nSummary:")
    print(f"Total datasets analyzed: {len(compression_rates)}")
    print(f"Average compression rate: {np.mean(list(compression_rates.values())):.1f}%")
    print(f"Range: {min(compression_rates.values()):.1f}% - {max(compression_rates.values()):.1f}%")


if __name__ == '__main__':
    args = parse_args()
    main(args)
